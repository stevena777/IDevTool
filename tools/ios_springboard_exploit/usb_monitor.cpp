/**
 * USB Device Monitor - Fast C++ implementation
 * Monitors for iPhone connection and reports device state
 */

#include <iostream>
#include <string>
#include <sstream>
#include <vector>
#include <chrono>
#include <thread>
#include <ctime>
#include <iomanip>
#include <plist/plist.h>
#include <libimobiledevice/libimobiledevice.h>
#include <libimobiledevice/lockdown.h>

class USBMonitor {
private:
    bool verbose;
    std::string last_udid;

    std::string get_timestamp() {
        auto now = std::chrono::system_clock::now();
        auto time = std::chrono::system_clock::to_time_t(now);
        std::stringstream ss;
        ss << std::put_time(std::localtime(&time), "%Y-%m-%d %H:%M:%S");
        return ss.str();
    }

    void log(const std::string& level, const std::string& message) {
        std::cout << "[" << get_timestamp() << "] [" << level << "] " << message << std::endl;
    }

public:
    USBMonitor(bool verbose_mode = true) : verbose(verbose_mode), last_udid("") {}

    bool check_device(std::string& udid_out) {
        char **devices = NULL;
        int count = 0;

        idevice_get_device_list(&devices, &count);

        if (count > 0 && devices && devices[0]) {
            udid_out = std::string(devices[0]);
            idevice_device_list_free(devices);
            return true;
        }

        if (devices) {
            idevice_device_list_free(devices);
        }
        return false;
    }

    bool get_device_info(const std::string& udid) {
        idevice_t device = NULL;
        lockdownd_client_t client = NULL;
        plist_t node = NULL;

        if (idevice_new(&device, udid.c_str()) != IDEVICE_E_SUCCESS) {
            log("ERROR", "Failed to connect to device");
            return false;
        }

        if (lockdownd_client_new_with_handshake(device, &client, "usb_monitor") != LOCKDOWN_E_SUCCESS) {
            log("WARN", "Lockdown handshake failed - device is locked");
            idevice_free(device);
            return false;
        }

        log("SUCCESS", "✓✓✓ LOCKDOWN CLIENT CREATED - Device accessible!");

        // Try to get device info
        char* device_name = NULL;
        char* product_version = NULL;
        char* product_type = NULL;

        lockdownd_get_device_name(client, &device_name);
        lockdownd_get_value(client, NULL, "ProductVersion", &node);
        if (node) {
            plist_get_string_val(node, &product_version);
            plist_free(node);
            node = NULL;
        }

        lockdownd_get_value(client, NULL, "ProductType", &node);
        if (node) {
            plist_get_string_val(node, &product_type);
            plist_free(node);
        }

        if (device_name) {
            log("INFO", std::string("Device Name: ") + device_name);
            free(device_name);
        }
        if (product_type) {
            log("INFO", std::string("Product Type: ") + product_type);
            free(product_type);
        }
        if (product_version) {
            log("INFO", std::string("iOS Version: ") + product_version);
            free(product_version);
        }

        lockdownd_client_free(client);
        idevice_free(device);
        return true;
    }

    bool check_pairing_status(const std::string& udid) {
        idevice_t device = NULL;
        lockdownd_client_t client = NULL;

        if (idevice_new(&device, udid.c_str()) != IDEVICE_E_SUCCESS) {
            return false;
        }

        lockdownd_error_t ret = lockdownd_client_new(device, &client, "usb_monitor");

        if (ret == LOCKDOWN_E_SUCCESS) {
            log("INFO", "Device is paired");
            lockdownd_client_free(client);
            idevice_free(device);
            return true;
        } else if (ret == LOCKDOWN_E_PAIRING_DIALOG_RESPONSE_PENDING) {
            log("WARN", "Pairing dialog pending - user needs to tap 'Trust'");
        } else if (ret == LOCKDOWN_E_INVALID_HOST_ID) {
            log("WARN", "Device not paired with this computer");
        } else {
            log("WARN", "Pairing check failed");
        }

        idevice_free(device);
        return false;
    }

    void monitor_continuous() {
        log("INFO", "=== USB Device Monitor Started ===");
        log("INFO", "Monitoring for iPhone connection...");
        log("INFO", "Trigger SpringBoard glitch NOW\n");

        bool device_was_connected = false;

        while (true) {
            std::string udid;
            bool connected = check_device(udid);

            if (connected && !device_was_connected) {
                log("DETECT", "✓ Device connected: " + udid);

                // Check pairing
                if (check_pairing_status(udid)) {
                    // Try to get device info
                    if (get_device_info(udid)) {
                        log("SUCCESS", "✓✓✓ DEVICE IS ACCESSIBLE!");
                        log("SUCCESS", "Run: python springboard_exploit.py");
                    }
                }

                device_was_connected = true;
                last_udid = udid;
            } else if (!connected && device_was_connected) {
                log("INFO", "Device disconnected");
                device_was_connected = false;
            }

            std::this_thread::sleep_for(std::chrono::milliseconds(500));
        }
    }
};

int main(int argc, char** argv) {
    std::cout << R"(
╔══════════════════════════════════════════════════════╗
║   iOS 26.2 USB Device Monitor                       ║
║   Fast C++ implementation for SpringBoard exploit    ║
╚══════════════════════════════════════════════════════╝
)" << std::endl;

    USBMonitor monitor(true);

    try {
        monitor.monitor_continuous();
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }

    return 0;
}
